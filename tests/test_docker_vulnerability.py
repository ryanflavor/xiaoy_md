"""Container vulnerability scanning tests for Docker image (Story 1.4).

Tests that validate container security through vulnerability scanning
to address SEC-001 critical risk identified in QA assessment.
"""

from datetime import datetime
import json
import os
from pathlib import Path
import shutil
import subprocess

import pytest

# Constants
MAX_BASE_IMAGE_AGE_DAYS = 90


@pytest.fixture(scope="module")
def docker_image():
    """Build Docker image once per test module and reuse it."""
    tag = "test-market-data:latest"

    # Build the image if not exists
    result = subprocess.run(
        ["docker", "images", tag, "--format", "{{.ID}}"],
        capture_output=True,
        text=True,
        check=False,
    )

    if not result.stdout.strip():
        # Image doesn't exist, build it
        build_result = build_docker_image_helper(tag, timeout=300)
        if build_result.returncode != 0:
            stderr_text = (
                build_result.stderr.decode()
                if isinstance(build_result.stderr, bytes)
                else build_result.stderr
            )
            pytest.fail(f"Failed to build Docker image: {stderr_text}")

    return tag


def build_docker_image_helper(
    tag: str, timeout: int = 300
) -> subprocess.CompletedProcess:
    """Build Docker image with proxy from environment or default."""
    build_args = [
        "docker",
        "build",
        "-t",
        tag,
        ".",
    ]

    # Default proxy for local environment
    default_proxy = "http://192.168.10.102:10808"

    # Get proxy from environment or use default
    http_proxy = (
        os.environ.get("HTTP_PROXY") or os.environ.get("http_proxy") or default_proxy
    )
    https_proxy = (
        os.environ.get("HTTPS_PROXY") or os.environ.get("https_proxy") or default_proxy
    )

    build_args.extend(["--build-arg", f"HTTP_PROXY={http_proxy}"])
    build_args.extend(["--build-arg", f"HTTPS_PROXY={https_proxy}"])

    return subprocess.run(
        build_args,
        capture_output=True,
        cwd=Path(__file__).parent.parent,
        timeout=timeout,
        check=False,
    )


def build_docker_image(tag: str, timeout: int = 120) -> subprocess.CompletedProcess:
    """Build Docker image with specified tag and timeout."""
    return build_docker_image_helper(tag, timeout)


class TestContainerVulnerabilityScanning:
    """Tests for container vulnerability scanning (SEC-001 mitigation)."""

    def test_docker_image_builds_for_scanning(self, docker_test_image):
        """Ensure Docker image can be built for vulnerability scanning."""
        # Image already built by fixture, just verify it exists
        result = subprocess.run(
            ["docker", "images", docker_test_image, "--format", "{{.ID}}"],
            capture_output=True,
            text=True,
            check=False,
        )
        assert result.stdout.strip(), f"Built image {docker_test_image} should exist"

    @pytest.mark.skipif(
        not (Path("~/.local/bin/trivy").expanduser().exists() or shutil.which("trivy")),
        reason="Trivy not installed - install with: brew install trivy or apt-get install trivy",
    )
    def test_trivy_vulnerability_scan(self, docker_test_image):
        """Run Trivy vulnerability scanner on Docker image (SEC-001)."""
        # Use pre-built image from fixture

        # Run Trivy scan with JSON output
        result = subprocess.run(
            [
                str(Path("~/.local/bin/trivy").expanduser()),
                "image",
                "--severity",
                "CRITICAL,HIGH",
                "--format",
                "json",
                "--exit-code",
                "0",  # Don't fail on vulnerabilities, we'll check manually
                docker_test_image,
            ],
            capture_output=True,
            text=True,
            timeout=300,
            check=False,
        )

        # Parse results
        if result.stdout:
            scan_results = json.loads(result.stdout)

            # Check for critical vulnerabilities
            critical_vulns = []
            high_vulns = []

            if "Results" in scan_results:
                for result_item in scan_results["Results"]:
                    if "Vulnerabilities" in result_item:
                        for vuln in result_item["Vulnerabilities"]:
                            if vuln.get("Severity") == "CRITICAL":
                                critical_vulns.append(vuln.get("VulnerabilityID"))
                            elif vuln.get("Severity") == "HIGH":
                                high_vulns.append(vuln.get("VulnerabilityID"))

            # Assert no critical vulnerabilities
            assert len(critical_vulns) == 0, (
                f"Critical vulnerabilities found: {critical_vulns}. "
                "Update base image or dependencies."
            )

            # Warn about high vulnerabilities but don't fail
            if high_vulns:
                print(f"Warning: {len(high_vulns)} high severity vulnerabilities found")

    @pytest.mark.skipif(
        subprocess.run(
            ["docker", "version"], capture_output=True, check=False
        ).returncode
        != 0,
        reason="Docker not available",
    )
    def test_base_image_currency(self):
        """Verify base image is recent (within 30 days recommended)."""
        # Get base image info
        result = subprocess.run(
            [
                "docker",
                "pull",
                "python:3.13-slim",
            ],
            capture_output=True,
            text=True,
            timeout=60,
            check=False,
        )

        # Check image creation date
        result = subprocess.run(
            [
                "docker",
                "inspect",
                "python:3.13-slim",
                "--format",
                "{{.Created}}",
            ],
            capture_output=True,
            text=True,
            check=False,
        )

        created_date = result.stdout.strip()
        assert created_date, "Should get base image creation date"

        # Parse and check age (basic check)

        # Parse ISO format date
        if created_date:
            # Remove microseconds and timezone for simpler parsing
            date_part = created_date.split("T")[0]
            created = datetime.fromisoformat(date_part)
            age = datetime.now() - created

            # Warn if older than 30 days
            assert age.days < MAX_BASE_IMAGE_AGE_DAYS, (
                f"Base image is {age.days} days old. "
                "Consider updating to a newer base image."
            )

    @pytest.mark.slow
    def test_no_vulnerable_packages(self, docker_test_image):
        """Check for known vulnerable packages in the image."""
        # Use pre-built image from fixture

        # List installed packages (override entrypoint to run pip)
        result = subprocess.run(
            [
                "docker",
                "run",
                "--rm",
                "--entrypoint",
                "pip",
                docker_test_image,
                "list",
                "--format",
                "json",
            ],
            capture_output=True,
            text=True,
            timeout=30,
            check=False,  # Reasonable timeout
        )

        if result.stdout:
            packages = json.loads(result.stdout)

            # Known vulnerable package versions (examples)
            vulnerable_packages = {
                "urllib3": ["1.26.4", "1.26.3"],  # Example vulnerable versions
                "requests": ["2.5.0", "2.5.1"],  # Example vulnerable versions
            }

            for package in packages:
                pkg_name = package.get("name", "").lower()
                pkg_version = package.get("version", "")

                if pkg_name in vulnerable_packages:
                    assert (
                        pkg_version not in vulnerable_packages[pkg_name]
                    ), f"Vulnerable version of {pkg_name} detected: {pkg_version}"


class TestRegistryPushValidation:
    """Tests for registry push validation (OPS-001 mitigation)."""

    def test_docker_push_simulation(self, docker_test_image):
        """Simulate registry push without actually pushing (OPS-001)."""
        # Use pre-built image from fixture

        # Get image manifest to validate it's push-ready
        subprocess.run(
            [
                "docker",
                "manifest",
                "inspect",
                docker_test_image,
            ],
            capture_output=True,
            check=False,
        )

        # The manifest command will fail for local images, which is expected
        # In real CI, this would validate against a test registry

        # Instead, validate image metadata
        result_str = subprocess.run(
            [
                "docker",
                "inspect",
                docker_test_image,
                "--format",
                "{{.RepoTags}}",
            ],
            capture_output=True,
            text=True,
            check=False,
        )

        assert docker_test_image in result_str.stdout, "Image should be properly tagged"

    def test_image_tagging_format(self, docker_test_image):
        """Verify image can be tagged with registry format."""
        # Use pre-built image from fixture

        # Tag with registry format (simulated)
        registry_tag = "ghcr.io/test/market-data-service:v1.0.0"
        result = subprocess.run(
            [
                "docker",
                "tag",
                docker_test_image,
                registry_tag,
            ],
            capture_output=True,
            check=False,
        )

        assert result.returncode == 0, "Should be able to tag with registry format"

        # Verify tag exists
        result_str = subprocess.run(
            [
                "docker",
                "images",
                registry_tag,
                "--format",
                "{{.Tag}}",
            ],
            capture_output=True,
            text=True,
            check=False,
        )

        assert "v1.0.0" in result_str.stdout, "Registry-formatted tag should exist"

        # Clean up
        subprocess.run(
            ["docker", "rmi", registry_tag], capture_output=True, check=False
        )

    def test_ci_prevents_actual_push(self):
        """Verify CI configuration doesn't actually push to registry."""
        ci_config_path = Path(__file__).parent.parent / ".github/workflows/ci.yml"
        content = ci_config_path.read_text()

        # Ensure no actual push commands
        assert (
            "docker push" not in content.lower()
        ), "CI should not contain 'docker push' command"

        # Ensure build-only configuration
        assert (
            "docker build" in content.lower() or "docker/build" in content.lower()
        ), "CI should build Docker image"

        # Check for --push=false or equivalent
        if "docker/build-push-action" in content:
            assert (
                "push: false" in content or 'push: "false"' in content
            ), "Build action should have push disabled"


class TestSecurityMitigations:
    """Tests for additional security mitigations from QA recommendations."""

    def test_dockerfile_has_security_labels(self):
        """Verify Dockerfile includes security-related labels."""
        dockerfile_path = Path(__file__).parent.parent / "Dockerfile"
        with open(dockerfile_path) as f:  # noqa: PTH123
            content = f.read()

        # Should have maintainer or security contact
        # (Currently may not exist, this is a recommendation)
        if "LABEL" in content:
            assert (
                "maintainer" in content.lower() or "security" in content.lower()
            ), "Consider adding security contact labels"

    def test_dockerfile_uses_copy_not_add(self):
        """Verify using COPY instead of ADD for better security."""
        dockerfile_path = Path(__file__).parent.parent / "Dockerfile"
        with open(dockerfile_path) as f:  # noqa: PTH123
            content = f.read()

        # ADD can extract archives and fetch URLs, COPY is more secure
        lines = content.split("\n")
        for line in lines:
            if line.strip().startswith("ADD"):
                # ADD is only acceptable for extracting local archives
                assert (
                    ".tar" in line or ".gz" in line
                ), f"Use COPY instead of ADD for: {line}"

    def test_no_unnecessary_packages(self):
        """Verify no unnecessary packages are installed."""
        dockerfile_path = Path(__file__).parent.parent / "Dockerfile"
        with open(dockerfile_path) as f:  # noqa: PTH123
            content = f.read()

        # Check for commonly unnecessary packages
        unnecessary = ["wget", "curl", "git", "ssh", "telnet", "ftp"]

        for pkg in unnecessary:
            # Allow if explicitly needed and documented
            if f"apt-get install.*{pkg}" in content or f"apk add.*{pkg}" in content:
                assert (
                    "# Required for" in content
                ), f"Package {pkg} should be documented if necessary"

    @pytest.mark.skipif(
        subprocess.run(
            [str(Path("~/.local/bin/hadolint").expanduser()), "--version"],
            capture_output=True,
            check=False,
        ).returncode
        != 0,
        reason="Hadolint not installed - install with: brew install hadolint",
    )
    def test_hadolint_dockerfile_linting(self):
        """Run Hadolint linter on Dockerfile for best practices."""
        dockerfile_path = Path(__file__).parent.parent / "Dockerfile"

        result = subprocess.run(
            [
                str(Path("~/.local/bin/hadolint").expanduser()),
                "--ignore",
                "DL3008",  # Pin versions in apt-get
                "--ignore",
                "DL3009",  # Delete apt lists
                str(dockerfile_path),
            ],
            capture_output=True,
            text=True,
            check=False,
        )

        assert (
            result.returncode == 0
        ), f"Dockerfile linting issues found:\n{result.stdout}"
