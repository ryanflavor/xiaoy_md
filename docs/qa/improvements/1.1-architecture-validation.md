# Architecture Validation Implementation Guide

## Hexagonal Architecture Enforcement from Day One

### 1. Import Boundary Checker (Critical)

```python
# scripts/check_architecture.py
"""
Hexagonal Architecture Boundary Enforcer
Prevents architecture violations at commit time
"""

import ast
import sys
from pathlib import Path
from typing import List, Tuple

class HexagonalValidator(ast.NodeVisitor):
    """AST visitor to validate hexagonal architecture boundaries"""

    LAYER_RULES = {
        'domain': {
            'forbidden_imports': ['adapters', 'infrastructure', 'api', 'web'],
            'allowed_imports': ['domain', 'typing', 'dataclasses', 'enum', 'abc'],
        },
        'application': {
            'forbidden_imports': ['adapters', 'infrastructure', 'api', 'web'],
            'allowed_imports': ['domain', 'application', 'typing'],
        },
        'adapters': {
            'forbidden_imports': [],  # Adapters can import from anywhere
            'allowed_imports': None,  # No restrictions
        }
    }

    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.violations = []
        self.current_layer = self._detect_layer(file_path)

    def _detect_layer(self, path: Path) -> str:
        """Detect which hexagonal layer this file belongs to"""
        parts = path.parts
        if 'domain' in parts:
            return 'domain'
        elif 'application' in parts:
            return 'application'
        elif 'adapters' in parts:
            return 'adapters'
        return 'unknown'

    def visit_Import(self, node):
        """Check import statements"""
        for alias in node.names:
            self._validate_import(alias.name)
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        """Check from...import statements"""
        if node.module:
            self._validate_import(node.module)
        self.generic_visit(node)

    def _validate_import(self, module_name: str):
        """Validate import against layer rules"""
        if not self.current_layer or self.current_layer == 'unknown':
            return

        rules = self.LAYER_RULES.get(self.current_layer, {})
        forbidden = rules.get('forbidden_imports', [])

        for forbidden_pattern in forbidden:
            if forbidden_pattern in module_name:
                self.violations.append(
                    f"Architecture violation in {self.file_path}:\n"
                    f"  Layer '{self.current_layer}' cannot import from '{module_name}'\n"
                    f"  Forbidden pattern: '{forbidden_pattern}'"
                )

def validate_architecture(src_path: str = "src") -> Tuple[bool, List[str]]:
    """Validate all Python files in src directory"""
    violations = []
    src_dir = Path(src_path)

    for py_file in src_dir.rglob("*.py"):
        with open(py_file, 'r', encoding='utf-8') as f:
            try:
                tree = ast.parse(f.read())
                validator = HexagonalValidator(py_file)
                validator.visit(tree)
                violations.extend(validator.violations)
            except SyntaxError as e:
                violations.append(f"Syntax error in {py_file}: {e}")

    return len(violations) == 0, violations

def main():
    """Main entry point for architecture validation"""
    print("🔍 Validating Hexagonal Architecture...")

    is_valid, violations = validate_architecture()

    if is_valid:
        print("✅ Architecture validation PASSED")
        return 0
    else:
        print("❌ Architecture validation FAILED\n")
        for violation in violations:
            print(f"  {violation}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

### 2. Pre-commit Hook Configuration

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: architecture-check
        name: Hexagonal Architecture Validation
        entry: python scripts/check_architecture.py
        language: python
        pass_filenames: false
        always_run: true

      - id: import-sort-check
        name: Import Sort Check
        entry: isort --check-only --diff
        language: system
        types: [python]

      - id: layer-dependency-check
        name: Layer Dependency Check
        entry: python scripts/check_dependencies.py
        language: python
        pass_filenames: false
```

### 3. Dependency Graph Generator

```python
# scripts/check_dependencies.py
"""Generate and validate dependency graphs for architecture"""

import ast
import json
from collections import defaultdict
from pathlib import Path
import subprocess

class DependencyAnalyzer:
    """Analyze dependencies between layers"""

    def __init__(self):
        self.dependencies = defaultdict(set)
        self.layer_deps = defaultdict(set)

    def analyze(self, src_path: str = "src"):
        """Analyze all dependencies in source"""
        src_dir = Path(src_path)

        for py_file in src_dir.rglob("*.py"):
            self._analyze_file(py_file)

    def _analyze_file(self, file_path: Path):
        """Analyze single file dependencies"""
        layer = self._get_layer(file_path)

        with open(file_path, 'r', encoding='utf-8') as f:
            try:
                tree = ast.parse(f.read())
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            target_layer = self._get_import_layer(alias.name)
                            if target_layer:
                                self.layer_deps[layer].add(target_layer)
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            target_layer = self._get_import_layer(node.module)
                            if target_layer:
                                self.layer_deps[layer].add(target_layer)
            except:
                pass  # Skip files with syntax errors

    def _get_layer(self, path: Path) -> str:
        """Get layer from path"""
        parts = path.parts
        if 'domain' in parts:
            return 'domain'
        elif 'application' in parts:
            return 'application'
        elif 'adapters' in parts:
            return 'adapters'
        return 'unknown'

    def _get_import_layer(self, module: str) -> str:
        """Get layer from import module name"""
        if 'domain' in module:
            return 'domain'
        elif 'application' in module:
            return 'application'
        elif 'adapters' in module:
            return 'adapters'
        return None

    def generate_mermaid(self) -> str:
        """Generate Mermaid diagram of dependencies"""
        lines = ["graph TD"]

        for source, targets in self.layer_deps.items():
            for target in targets:
                lines.append(f"    {source} --> {target}")

        return "\n".join(lines)

    def validate(self) -> Tuple[bool, List[str]]:
        """Validate dependency rules"""
        violations = []

        # Domain should not depend on anything except itself
        if 'domain' in self.layer_deps:
            domain_deps = self.layer_deps['domain']
            invalid = domain_deps - {'domain'}
            if invalid:
                violations.append(f"Domain layer depends on: {invalid}")

        # Application should only depend on domain
        if 'application' in self.layer_deps:
            app_deps = self.layer_deps['application']
            invalid = app_deps - {'domain', 'application'}
            if invalid:
                violations.append(f"Application layer has invalid dependencies: {invalid}")

        return len(violations) == 0, violations
```

### 4. PyTest Architecture Tests

```python
# tests/test_architecture.py
"""Architecture compliance tests - run with every test suite"""

import pytest
from pathlib import Path
import ast
import importlib.util

class TestHexagonalArchitecture:
    """Test suite for architecture compliance"""

    def test_domain_has_no_external_dependencies(self):
        """Domain layer must be pure - no framework dependencies"""
        domain_path = Path("src/domain")

        for py_file in domain_path.rglob("*.py"):
            with open(py_file) as f:
                tree = ast.parse(f.read())

            imports = []
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    imports.extend(n.name for n in node.names)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.append(node.module)

            # Check no framework imports
            forbidden = ['fastapi', 'django', 'flask', 'sqlalchemy', 'adapters']
            violations = [imp for imp in imports if any(f in imp for f in forbidden)]

            assert not violations, f"Domain file {py_file} has forbidden imports: {violations}"

    def test_application_only_uses_domain(self):
        """Application layer should only import from domain"""
        app_path = Path("src/application")

        for py_file in app_path.rglob("*.py"):
            with open(py_file) as f:
                tree = ast.parse(f.read())

            imports = []
            for node in ast.walk(tree):
                if isinstance(node, ast.ImportFrom):
                    if node.module and node.module.startswith('src'):
                        imports.append(node.module)

            # Check only domain imports
            violations = [imp for imp in imports
                         if 'src.' in imp and 'domain' not in imp and 'application' not in imp]

            assert not violations, f"Application file {py_file} imports from: {violations}"

    def test_ports_are_abstract(self):
        """All ports must be abstract base classes"""
        ports_path = Path("src/domain/ports")

        if not ports_path.exists():
            pytest.skip("No ports directory yet")

        for py_file in ports_path.rglob("*.py"):
            spec = importlib.util.spec_from_file_location("module", py_file)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            for name in dir(module):
                obj = getattr(module, name)
                if isinstance(obj, type) and name.endswith('Port'):
                    # Check it's abstract
                    assert hasattr(obj, '__abstractmethods__'), \
                        f"Port {name} in {py_file} must be abstract"

    def test_no_circular_dependencies(self):
        """Ensure no circular dependencies exist"""
        from scripts.check_dependencies import DependencyAnalyzer

        analyzer = DependencyAnalyzer()
        analyzer.analyze()

        # Simple cycle detection
        for source, targets in analyzer.layer_deps.items():
            for target in targets:
                # Check if target also depends on source
                if source in analyzer.layer_deps.get(target, set()):
                    pytest.fail(f"Circular dependency: {source} <-> {target}")
```

### 5. Visual Architecture Validation

```python
# scripts/visualize_architecture.py
"""Generate visual architecture diagrams"""

import subprocess
from pathlib import Path

def generate_architecture_diagram():
    """Generate architecture visualization"""

    mermaid_content = """
    graph TB
        subgraph "External World"
            API[REST API]
            DB[(Database)]
            MSG[Message Queue]
        end

        subgraph "Adapters Layer"
            APIADAPTER[API Adapter]
            DBADAPTER[DB Adapter]
            MSGADAPTER[Message Adapter]
        end

        subgraph "Application Layer"
            USECASE[Use Cases]
            APPSERVICE[Application Services]
        end

        subgraph "Domain Layer"
            ENTITY[Entities]
            VALUEOBJ[Value Objects]
            DOMAINSERVICE[Domain Services]
            PORT[Ports/Interfaces]
        end

        API --> APIADAPTER
        APIADAPTER --> PORT
        PORT --> USECASE
        USECASE --> DOMAINSERVICE
        DOMAINSERVICE --> ENTITY
        DOMAINSERVICE --> VALUEOBJ

        USECASE --> PORT
        PORT --> DBADAPTER
        DBADAPTER --> DB

        MSG --> MSGADAPTER
        MSGADAPTER --> PORT

        style "Domain Layer" fill:#90EE90
        style "Application Layer" fill:#87CEEB
        style "Adapters Layer" fill:#FFB6C1
        style "External World" fill:#D3D3D3
    """

    # Save and render
    Path("docs/architecture-diagram.mmd").write_text(mermaid_content)

    # Generate PNG using mermaid CLI if available
    try:
        subprocess.run([
            "mmdc", "-i", "docs/architecture-diagram.mmd",
            "-o", "docs/architecture-diagram.png"
        ])
        print("✅ Architecture diagram generated: docs/architecture-diagram.png")
    except:
        print("ℹ️ Mermaid CLI not found, saved as .mmd file")

if __name__ == "__main__":
    generate_architecture_diagram()
```

### 6. Continuous Architecture Validation

```yaml
# .github/workflows/architecture.yml
name: Architecture Validation

on:
  pull_request:
    paths:
      - 'src/**'
      - 'scripts/check_architecture.py'

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Validate Architecture
        run: |
          python scripts/check_architecture.py
          python scripts/check_dependencies.py

      - name: Run Architecture Tests
        run: |
          uv sync
          uv run pytest tests/test_architecture.py -v

      - name: Generate Architecture Report
        run: |
          python scripts/visualize_architecture.py

      - name: Upload Architecture Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: architecture-report
          path: docs/architecture-diagram.*
```

---
*Architecture Validation Guide - Story 1.1*
*Generated by Quinn (Test Architect)*
